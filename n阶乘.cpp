//1、 给定一个整数N，那么N的阶乘N！末尾有多少个0呢？
//计算n的阶乘n！末尾的“0”的个数，可以转换为计算其因式分解中“5”的个数
//第一种
int ZeroNum(int n){
int k = n/5;
	if(n>0 && n<5)
		return 0;
	else
		return (k+ZeroNum(k));
}

//第二种
int ZeroNum(int n){
	int num = 0;
	for(int i=5;i<=n; i+=5){
		int temp = i;
		
		while(0 == temp%5){
			num++;
			temp /=5;
		}
	}
	return num;
}

//最优算法
int numOfZero(int n)  
{  
    int num = 0, i;  
    for(i=5; i<=n; i*=5)  
    {  
        num += n/i;  
    }  
    return num;  
}  

//2、求N！的二进制表示中最低位1的位置。
//这个问题实际上等同于求N！含有质因数2的个数+1。即答案等于N！含有质因数2的个数加1

由于N! 中含有质因数2的个数，等于 N/2 + N/4 + N/8 + N/16 + …[1]，

根据上述分析，得到具体算法，如下所示：

[cpp] view plaincopy
/* 
可以先求出N!中2的个数（因为每存在一个2，则在数的  
最低位多1个0）。因此求1的最低位的位置即为N!中2的个数+1；  
*/  
int lowestOnePos(int n)   
{   
    int ret = 0;     //统计n!中含有质因数2的个数  
    while(n)   
    {   
        n >>= 1;   
        ret += n;   
    }   
    return ret+1;  
}  
【问题2的解法二】

N！含有质因数2的个数，还等于N减去N的二进制表示中1的数目。我们还可以通过这个规律来求解。

下面对这个规律进行举例说明，假设 N = 11011，那么N!中含有质因数2的个数为 N/2 + N/4 + N/8 + N/16 + …

即： 1101 + 110 + 11 + 1

=（1000 + 100 + 1）

+（100 + 10）

+（10 + 1）

+ 1

=（1000 + 100+ 10 + 1）+（100 + 10 + 1）+ 1

= 1111 + 111 + 1

=（10000 -1）+（1000 - 1）+（10-1）+（1-1）

= 11011-N二进制表示中1的个数

小结
任意一个长度为m的二进制数N可以表示为N = b[1] + b[2] * 2 + b[3] * 22 + … + b[m] * 2(m-1)，其中b [ i ]表示此二进制数第i位上的数字（1或0）。所以，若最低位b[1]为1，则说明N为奇数；反之为偶数，将其除以2，即等于将整个二进制数向低位移一位。

相关题目
给定整数n，判断它是否为2的方幂（解答提示：n>0&&（（n&（n-1））==0））
